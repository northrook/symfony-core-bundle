<?php

declare( strict_types = 1 );

namespace Northrook\Symfony\Core;

use Northrook\Logger\Log;
use Northrook\Symfony\Support\Console\Output;
use Symfony\Component\Filesystem\Exception\IOException;
use Symfony\Component\Filesystem\Filesystem;
use function Northrook\Core\Function\normalizePath;

/**
 * @internal
 * @author Martin Nielsen <mn@northrook.com>
 */
final readonly class AutoConfigure
{

    private Filesystem $file;
    private string     $configDirectory;

    public function __construct(
        private string $projectDirectory,
    ) {
        $this->file            = new Filesystem();
        $this->configDirectory = normalizePath( $this->projectDirectory . '/config' );

        if ( 'cli' === PHP_SAPI ) {
            Output::init( 'AutoConfigure called by ' . SymfonyCoreBundle::class );
        }
        else {
            // AutoConfigure should only be called by CLI or when SymfonyCoreBundle is building the container.
            die;
        }
    }

    public function configPreload() : self {
        $this->createConfigFile(
            'preload.php',
            <<<PHP
                <?php

                declare( strict_types = 1 );

                if ( file_exists( dirname( __DIR__ ) . '/var/cache/prod/App_KernelProdContainer.preload.php' ) ) {
                    opcache_compile_file( dirname( __DIR__ ) . '/var/cache/prod/App_KernelProdContainer.preload.php' );
                }
                PHP,
        );

        return $this;
    }

    public function configRoutes() : self {
        $this->removeFile( 'routes.yaml' );
        $this->createConfigFile(
            'routes.php',
            <<<PHP
                <?php

                declare( strict_types = 1 );

                use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

                return static function ( RoutingConfigurator \$routes ) : void {
                    \$routes->import(
                        [
                            'path'      => '../src/Controller/',
                            'namespace' => 'App\Controller',
                        ],
                        'attribute',
                    );
                };
                PHP,
        );

        return $this;
    }

    public function configServices() : self {
        $this->removeFile( 'services.yaml' );
        $this->createConfigFile(
            'services.php',
            <<<PHP
                <?php

                declare( strict_types = 1 );

                use Symfony\Component\DependencyInjection\Loader\Configurator\ContainerConfigurator;

                return static function ( ContainerConfigurator \$container ) : void {

                    \$services = \$container->services();

                    // Defaults for App services.
                    \$services
                        ->defaults()
                        ->autowire()
                        ->autoconfigure();

                    \$services
                        // Make classes in src/ available to be used as services.
                        ->load( "App\\\\", __DIR__ . '/../src/' )
                        // We do not want to autowire DI, ORM, or Kernel classes.
                        ->exclude(
                            [
                                __DIR__ . '/../src/DependencyInjection/',
                                __DIR__ . '/../src/Entity/',
                                __DIR__ . '/../src/Kernel.php',
                            ],
                        );
                };
                PHP,
        );
        return $this;
    }

    private function removeFile( string $name ) : void {

        $path = normalizePath( "{$this->configDirectory}/{$name}" );

        if ( !$this->file->exists( $path ) ) {
            return;
        }

        try {
            $this->file->remove( $path );
            Output::info( "AutoConfigure removed config/$name." );
        }
        catch ( IOException $e ) {
            $message = "AutoConfigure: Could not remove config/$name. {$e->getMessage()}";
            Log::Error( message : $message, context : [ 'exception' => $e ] );
            Output::error( $message );
        }

    }

    private function createConfigFile( string $name, string $config ) : void {

        $path = normalizePath( "{$this->configDirectory}/{$name}" );

        if ( $this->file->exists( $path ) ) {
            return;
        }

        if ( !str_starts_with( $config, '<?php' ) ) {
            Output::error( 'AutoConfigure: Could not create ' . $name . ', it is not a valid PHP file.' );
            return;
        }

        $content = preg_replace(
            pattern     : '#<\?php\s+?(?=\S)#A',
            replacement : "<?php\n\n// Generated by Northrook\Symfony\Core\AutoConfigure\n\n",
            subject     : $config,
        );

        try {
            $this->file->dumpFile( $path, $content );
            Output::OK( "AutoConfigure: Generated config/$name." );
        }
        catch ( IOException $exception ) {
            $message = "AutoConfigure: Could not generate config/$name. {$exception->getMessage()}";
            Log::Error(
                message : $message,
                context : [ 'exception' => $exception, 'path' => $path ],
            );
            Output::error( $message );
        }
    }
}